program = { SOI ~ statement+ ~ EOI }
statement = { function | type_definition | class_definition | class_declaration | variable_definition | return_statement }

//* functions start *//
function_header = { "function" ~ identifier ~ generics? ~ "(" ~ function_definition_arguments? ~ ")" ~ ("->" ~ type)? }
function = { function_header ~ block }

function_call = { non_call_expression ~ "(" ~ function_call_arguments? ~ ")" }
nested_function_call = { function_call ~ "(" ~ function_call_arguments? ~ ")" }

function_definition_arguments = { identifier ~ ":" ~ type ~ ("," ~ identifier ~ ":" ~ type)* }
function_call_arguments = { expression ~ ("," ~ expression)* }
//* functions end *//

//* classes start *//
stmt_sep = _{ ";" } // statement_separator

class_declaration = { "declare"? ~ "class" ~ identifier ~ generics? ~ "{" ~ class_declaration_member* ~ "}" ~ stmt_sep? }
class_declaration_member = { class_declaration_function | class_declaration_variable }

class_declaration_function = { attributes? ~ function_header ~ stmt_sep }
class_declaration_variable = { identifier ~ ":" ~ type ~ stmt_sep }

class_definition = { "class" ~ identifier ~ generics? ~ "{" ~ class_definition_member* ~ "}" ~ stmt_sep? }
class_definition_member = { class_definition_function | class_definition_variable }

class_definition_function = { attributes? ~ function ~ stmt_sep? }
class_definition_variable = { identifier ~ ":" ~ type ~ ("=" ~ expression)? ~ stmt_sep }
//* classes end *//

variable_definition = { "var" ~ identifier ~ (":" ~ type)? ~ "=" ~ expression ~ stmt_sep }
attributes = { "#[" ~ attribute_identifier ~ ("," ~ attribute_identifier)* ~ "]" }
attribute_identifier = { "constructor" | "private" | "public" | "get" | "set" | "static" }
block = { "{" ~ statement* ~ "}" ~ stmt_sep? }

//* types start *//
generics = { "<" ~ identifier ~ ("," ~ identifier)* ~ ">" }

base_type = { identifier ~ generics? }
array_type = { base_type ~ ("[" ~ "]")+ }

type = { array_type | base_type }
type_definition = { "type" ~ identifier ~ generics? ~ "=" ~ type }
//* types end *//

array_expression = { "[" ~ (expression ~ ("," ~ expression)* )? ~ "]" }
non_call_expression = { literal | identifier | array_expression | binary_op | unary_op }
expression = _{ chained_call | literal | identifier | function_call | nested_function_call | array_expression | binary_op | unary_op }

call_chain_segment = _{ ("." | "->") ~ identifier ~ ("(" ~ function_call_arguments? ~ ")")? }
chained_call = _{ non_call_expression ~ (call_chain_segment)* }

binary_op = { unary_op ~ ("+" ~ unary_op | "-" ~ unary_op | "*" ~ unary_op | "/" ~ unary_op | "==" ~ unary_op)* }
unary_op = { ("-" | "!") ~ expression }

literal = { string_literal | number_literal }
string_literal = { "\"" ~ (!("\"") ~ ANY)* ~ "\"" }
number_literal = { ("-"? ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* ~ ("." ~ ASCII_DIGIT+)?) | "0" }

identifier = { (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

//* other statements *//
return_statement = { "return" ~ expression? ~ stmt_sep }

//* to be ignored *//
line_comment = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" }
block_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

COMMENT = _{ line_comment | block_comment }
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }